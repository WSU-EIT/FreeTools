using System.Text;
using System.Text.RegularExpressions;
using FreeTools.Core;

namespace FreeTools.WorkspaceReporter;

internal partial class Program
{
    private static async Task<int> Main(string[] args)
    {
        // Robustness: Optional startup delay
        var delayEnv = Environment.GetEnvironmentVariable("START_DELAY_MS");
        if (int.TryParse(delayEnv, out var delayMs) && delayMs > 0)
        {
            Console.WriteLine($"Delaying start by {delayMs} ms...");
            await Task.Delay(delayMs);
        }

        ConsoleOutput.PrintBanner("WorkspaceReporter (FreeTools)", "1.0");

        var repoRoot = Environment.GetEnvironmentVariable("REPO_ROOT")
            ?? CliArgs.GetPositional(args.ToList(), 0)
            ?? FindRepoRoot(AppContext.BaseDirectory);

        if (string.IsNullOrEmpty(repoRoot) || !Directory.Exists(repoRoot))
        {
            Console.Error.WriteLine($"Repository root not found: {repoRoot}");
            return 1;
        }

        repoRoot = Path.GetFullPath(repoRoot);

        var outputPath = Environment.GetEnvironmentVariable("OUTPUT_PATH")
            ?? CliArgs.GetPositional(args.ToList(), 1)
            ?? Path.Combine(repoRoot, "LatestReport.md");

        var workspaceCsv = Environment.GetEnvironmentVariable("WORKSPACE_CSV")
            ?? Path.Combine(repoRoot, "workspace-inventory.csv");
        var workspaceCsharpCsv = Environment.GetEnvironmentVariable("WORKSPACE_CSHARP_CSV")
            ?? Path.Combine(repoRoot, "workspace-inventory-csharp.csv");
        var workspaceRazorCsv = Environment.GetEnvironmentVariable("WORKSPACE_RAZOR_CSV")
            ?? Path.Combine(repoRoot, "workspace-inventory-razor.csv");

        var webProjectRoot = Environment.GetEnvironmentVariable("WEB_PROJECT_ROOT")
            ?? Path.Combine(repoRoot, "Web", "FreeTools.Web");

        var pagesCsv = Environment.GetEnvironmentVariable("PAGES_CSV")
            ?? Path.Combine(webProjectRoot, "pages.csv");
        var snapshotsDir = Environment.GetEnvironmentVariable("SNAPSHOTS_DIR")
            ?? Path.Combine(webProjectRoot, "page-snapshots");

        ConsoleOutput.PrintConfig("Repo Root", repoRoot);
        ConsoleOutput.PrintConfig("Output Path", outputPath);
        ConsoleOutput.PrintConfig("Workspace CSV", workspaceCsv);
        ConsoleOutput.PrintConfig("Pages CSV", pagesCsv);
        ConsoleOutput.PrintConfig("Snapshots Dir", snapshotsDir);
        ConsoleOutput.PrintDivider();
        Console.WriteLine();

        var sb = new StringBuilder();

        sb.AppendLine("# 📊 FreeTools Workspace Report");
        sb.AppendLine();
        sb.AppendLine($"> **Generated:** {DateTime.Now:yyyy-MM-dd HH:mm:ss}  ");
        sb.AppendLine($"> **Repository:** {Path.GetFileName(repoRoot)}  ");
        sb.AppendLine($"> **Scope:** Blazor pages only — API endpoints not included  ");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();

        sb.AppendLine("## 📑 Table of Contents");
        sb.AppendLine();
        sb.AppendLine("- [About This Report](#-about-this-report)");
        sb.AppendLine("- [Workspace Overview](#-workspace-overview)");
        sb.AppendLine("- [File Statistics](#-file-statistics)");
        sb.AppendLine("- [Code Distribution](#-code-distribution)");
        sb.AppendLine("- [Largest Files](#-largest-files)");
        sb.AppendLine("- [Blazor Page Routes](#-blazor-page-routes)");
        sb.AppendLine("- [Screenshot Gallery](#-screenshot-gallery)");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();

        sb.AppendLine("## 📋 About This Report");
        sb.AppendLine();
        sb.AppendLine("This report is auto-generated by the **WorkspaceReporter** tool pipeline.");
        sb.AppendLine();
        sb.AppendLine("### Scope");
        sb.AppendLine();
        sb.AppendLine("| Included | Not Included |");
        sb.AppendLine("|----------|--------------|");
        sb.AppendLine("| ✅ Blazor pages (`@page` directives) | ❌ API endpoints (`/api/*`) |");
        sb.AppendLine("| ✅ Razor components | ❌ Dynamic routes (MapGet/MapPost) |");
        sb.AppendLine("| ✅ C# source files | ❌ Routes with parameters (`{id}`) |");
        sb.AppendLine("| ✅ Configuration files | |");
        sb.AppendLine();
        sb.AppendLine("### File Categories (Kind)");
        sb.AppendLine();
        sb.AppendLine("| Kind | Description |");
        sb.AppendLine("|------|-------------|");
        sb.AppendLine("| **RazorPage** | `.razor` file with `@page` directive (routable) |");
        sb.AppendLine("| **RazorComponent** | `.razor` file without `@page` (reusable component) |");
        sb.AppendLine("| **CSharpSource** | `.cs` file (classes, services, etc.) |");
        sb.AppendLine("| **ProjectFile** | `.csproj` file (project configuration) |");
        sb.AppendLine("| **SolutionFile** | `.sln` file (solution configuration) |");
        sb.AppendLine("| **Config** | `.json`, `.xml`, `.yaml`, `.yml`, `.config` files |");
        sb.AppendLine("| **Markdown** | `.md` documentation files |");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();

        Console.WriteLine("Processing workspace inventory...");
        var workspaceStats = await ProcessWorkspaceInventoryAsync(workspaceCsv, workspaceCsharpCsv, workspaceRazorCsv, sb);

        Console.WriteLine("Processing pages CSV...");
        await ProcessPagesCsvAsync(pagesCsv, sb);

        Console.WriteLine("Generating screenshot gallery...");
        await GenerateScreenshotGalleryAsync(snapshotsDir, webProjectRoot, repoRoot, sb);

        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("## 🔧 Tool Information");
        sb.AppendLine();
        sb.AppendLine("This report was generated by the **WorkspaceReporter** tool, which aggregates outputs from:");
        sb.AppendLine();
        sb.AppendLine("| Tool | Purpose |");
        sb.AppendLine("|------|---------|");
        sb.AppendLine("| **WorkspaceInventory** | Scans codebase, extracts metrics and classifications |");
        sb.AppendLine("| **PageScanner** | Discovers Blazor routes from @page directives |");
        sb.AppendLine("| **PageTester** | Performs HTTP GET requests to verify routes |");
        sb.AppendLine("| **PageScreenshoter** | Captures full-page screenshots with Playwright |");
        sb.AppendLine();
        sb.AppendLine("*Part of the FreeTools suite*");

        Console.WriteLine();
        Console.WriteLine($"Writing report to: {outputPath}");
        
        var outputDir = Path.GetDirectoryName(outputPath);
        if (!string.IsNullOrEmpty(outputDir) && !Directory.Exists(outputDir))
        {
            Directory.CreateDirectory(outputDir);
        }

        await File.WriteAllTextAsync(outputPath, sb.ToString(), Encoding.UTF8);

        Console.WriteLine();
        Console.WriteLine("============================================================");
        Console.WriteLine("                    REPORT COMPLETE");
        Console.WriteLine("============================================================");
        Console.WriteLine($"  Output: {outputPath}");
        Console.WriteLine($"  Size: {new FileInfo(outputPath).Length:N0} bytes");
        Console.WriteLine("============================================================");

        return 0;
    }

    private static async Task<WorkspaceStats> ProcessWorkspaceInventoryAsync(
        string workspaceCsv, string csharpCsv, string razorCsv, StringBuilder sb)
    {
        var stats = new WorkspaceStats();

        if (!File.Exists(workspaceCsv))
        {
            sb.AppendLine("## ⚠️ Workspace Overview");
            sb.AppendLine();
            sb.AppendLine("> Workspace inventory CSV not found. Run WorkspaceInventory first.");
            sb.AppendLine();
            return stats;
        }

        var lines = await File.ReadAllLinesAsync(workspaceCsv);
        if (lines.Length < 2)
        {
            sb.AppendLine("## ⚠️ Workspace Overview");
            sb.AppendLine();
            sb.AppendLine("> Workspace inventory CSV is empty.");
            sb.AppendLine();
            return stats;
        }

        var files = new List<FileEntry>();
        var kindCounts = new Dictionary<string, int>();
        var extensionCounts = new Dictionary<string, int>();
        long totalLines = 0;
        long totalChars = 0;
        long totalSize = 0;

        for (int i = 1; i < lines.Length; i++)
        {
            var entry = ParseCsvLine(lines[i]);
            if (entry is null) continue;

            files.Add(entry);
            totalSize += entry.SizeBytes;
            totalLines += entry.LineCount;
            totalChars += entry.CharCount;

            if (!string.IsNullOrEmpty(entry.Kind))
            {
                kindCounts.TryGetValue(entry.Kind, out var kc);
                kindCounts[entry.Kind] = kc + 1;
            }

            if (!string.IsNullOrEmpty(entry.Extension))
            {
                extensionCounts.TryGetValue(entry.Extension, out var ec);
                extensionCounts[entry.Extension] = ec + 1;
            }
        }

        stats.TotalFiles = files.Count;
        stats.TotalLines = totalLines;
        stats.TotalSize = totalSize;

        sb.AppendLine("## 📁 Workspace Overview");
        sb.AppendLine();
        sb.AppendLine("| Metric | Value |");
        sb.AppendLine("|--------|-------|");
        sb.AppendLine($"| **Total Files** | {files.Count:N0} |");
        sb.AppendLine($"| **Total Lines** | {totalLines:N0} |");
        sb.AppendLine($"| **Total Characters** | {totalChars:N0} |");
        sb.AppendLine($"| **Total Size** | {PathSanitizer.FormatBytes(totalSize)} |");
        sb.AppendLine();

        sb.AppendLine("## 📈 File Statistics");
        sb.AppendLine();
        sb.AppendLine("### By Category");
        sb.AppendLine();
        sb.AppendLine("| Category | Count | Percentage |");
        sb.AppendLine("|----------|------:|------------|");

        foreach (var kvp in kindCounts.OrderByDescending(k => k.Value))
        {
            var pct = files.Count > 0 ? (kvp.Value * 100.0 / files.Count) : 0;
            var bar = GenerateProgressBar(pct, 20);
            sb.AppendLine($"| {kvp.Key} | {kvp.Value:N0} | {bar} {pct:F1}% |");
        }
        sb.AppendLine();

        // Add expandable file lists for each category
        sb.AppendLine("### Files by Category");
        sb.AppendLine();
        
        var filesByKind = files
            .GroupBy(f => f.Kind ?? "Unknown")
            .OrderByDescending(g => g.Count())
            .ToList();

        foreach (var group in filesByKind)
        {
            sb.AppendLine($"<details>");
            sb.AppendLine($"<summary><strong>{group.Key}</strong> ({group.Count()} files)</summary>");
            sb.AppendLine();
            sb.AppendLine("| File | Lines | Size |");
            sb.AppendLine("|------|------:|-----:|");
            
            foreach (var file in group.OrderBy(f => f.RelativePath))
            {
                // Create a relative link that works on GitHub (from report location to source file)
                // The report is in Docs/runs/{Project}/{Branch}/latest/
                // Source files are in the project root, so we need to go up and reference them
                var linkPath = file.RelativePath.Replace('\\', '/');
                var displayPath = ShortenPath(file.RelativePath, 60);
                sb.AppendLine($"| [{displayPath}](../../../../{linkPath}) | {file.LineCount:N0} | {PathSanitizer.FormatBytes(file.SizeBytes)} |");
            }
            
            sb.AppendLine();
            sb.AppendLine("</details>");
            sb.AppendLine();
        }

        sb.AppendLine("## 📊 Code Distribution");
        sb.AppendLine();
        sb.AppendLine("### Lines of Code by Category");
        sb.AppendLine();
        sb.AppendLine("```");

        var linesByKind = files
            .GroupBy(f => f.Kind ?? "Unknown")
            .Select(g => new { Kind = g.Key, Lines = g.Sum(f => f.LineCount) })
            .OrderByDescending(x => x.Lines)
            .ToList();

        var maxLines = linesByKind.FirstOrDefault()?.Lines ?? 1;
        foreach (var item in linesByKind)
        {
            var barWidth = (int)(item.Lines * 40.0 / maxLines);
            var bar = new string('█', Math.Max(1, barWidth));
            sb.AppendLine($"{item.Kind,-20} {bar} {item.Lines:N0}");
        }
        sb.AppendLine("```");
        sb.AppendLine();

        sb.AppendLine("### By Extension");
        sb.AppendLine();
        sb.AppendLine("```");
        var maxExtCount = extensionCounts.Values.DefaultIfEmpty(1).Max();
        foreach (var kvp in extensionCounts.OrderByDescending(k => k.Value).Take(10))
        {
            var barWidth = (int)(kvp.Value * 30.0 / maxExtCount);
            var bar = new string('█', Math.Max(1, barWidth));
            sb.AppendLine($"{kvp.Key,-10} {bar} {kvp.Value:N0}");
        }
        sb.AppendLine("```");
        sb.AppendLine();

        sb.AppendLine("## 📏 Largest Files");
        sb.AppendLine();
        sb.AppendLine("### Top 15 C# Files by Line Count");
        sb.AppendLine();

        var topCsFiles = files
            .Where(f => f.Extension == ".cs")
            .OrderByDescending(f => f.LineCount)
            .Take(15)
            .ToList();

        if (topCsFiles.Count > 0)
        {
            sb.AppendLine("| # | File | Lines | Size |");
            sb.AppendLine("|--:|------|------:|-----:|");
            for (int i = 0; i < topCsFiles.Count; i++)
            {
                var f = topCsFiles[i];
                var shortPath = ShortenPath(f.RelativePath, 50);
                sb.AppendLine($"| {i + 1} | `{shortPath}` | {f.LineCount:N0} | {PathSanitizer.FormatBytes(f.SizeBytes)} |");
            }
        }
        else
        {
            sb.AppendLine("> No C# files found.");
        }
        sb.AppendLine();

        sb.AppendLine("### Top 15 Razor Files by Line Count");
        sb.AppendLine();

        var topRazorFiles = files
            .Where(f => f.Extension == ".razor")
            .OrderByDescending(f => f.LineCount)
            .Take(15)
            .ToList();

        if (topRazorFiles.Count > 0)
        {
            sb.AppendLine("| # | File | Lines | Kind |");
            sb.AppendLine("|--:|------|------:|------|");
            for (int i = 0; i < topRazorFiles.Count; i++)
            {
                var f = topRazorFiles[i];
                var shortPath = ShortenPath(f.RelativePath, 50);
                sb.AppendLine($"| {i + 1} | `{shortPath}` | {f.LineCount:N0} | {f.Kind} |");
            }
        }
        else
        {
            sb.AppendLine("> No Razor files found.");
        }
        sb.AppendLine();

        return stats;
    }

    private static async Task ProcessPagesCsvAsync(string pagesCsv, StringBuilder sb)
    {
        sb.AppendLine("## 🛤️ Blazor Page Routes");
        sb.AppendLine();
        sb.AppendLine("> **Note:** This section shows Blazor pages with `@page` directives only.");
        sb.AppendLine("> API endpoints (`/api/*`) are not included. Routes with parameters are skipped.");
        sb.AppendLine();

        if (!File.Exists(pagesCsv))
        {
            sb.AppendLine("> Pages CSV not found. Run PageScanner first.");
            sb.AppendLine();
            return;
        }

        var lines = await File.ReadAllLinesAsync(pagesCsv);
        if (lines.Length < 2)
        {
            sb.AppendLine("> Pages CSV is empty.");
            sb.AppendLine();
            return;
        }

        var routes = new List<RouteEntry>();
        var skippedRoutes = new List<RouteEntry>();
        var authRequired = 0;
        var publicRoutes = 0;

        for (int i = 1; i < lines.Length; i++)
        {
            var parts = lines[i].Split(',');
            if (parts.Length < 4) continue;

            var route = parts[1].Trim('"').Trim();
            var requiresAuth = parts[2].Trim().ToLower() == "true";
            var project = parts[3].Trim('"').Trim();

            if (string.IsNullOrEmpty(route)) continue;

            var entry = new RouteEntry
            {
                Route = route,
                RequiresAuth = requiresAuth,
                Project = project
            };

            if (RouteParser.HasParameter(route))
            {
                skippedRoutes.Add(entry);
                continue;
            }

            routes.Add(entry);

            if (requiresAuth)
                authRequired++;
            else
                publicRoutes++;
        }

        sb.AppendLine("### Route Summary");
        sb.AppendLine();
        sb.AppendLine("| Metric | Count |");
        sb.AppendLine("|--------|------:|");
        sb.AppendLine($"| **Testable Routes** | {routes.Count} |");
        sb.AppendLine($"| **Public Routes** | {publicRoutes} |");
        sb.AppendLine($"| **Auth Required** | {authRequired} |");
        sb.AppendLine($"| **Skipped (parameters)** | {skippedRoutes.Count} |");
        sb.AppendLine();

        if (routes.Count > 0)
        {
            var publicPct = publicRoutes * 100.0 / routes.Count;
            var authPct = authRequired * 100.0 / routes.Count;

            sb.AppendLine("### Access Distribution");
            sb.AppendLine();
            sb.AppendLine("```");
            sb.AppendLine($"🔓 Public:     {GenerateProgressBar(publicPct, 30)} {publicPct:F0}%");
            sb.AppendLine($"🔐 Protected:  {GenerateProgressBar(authPct, 30)} {authPct:F0}%");
            sb.AppendLine("```");
            sb.AppendLine();
        }

        var routesByProject = routes.GroupBy(r => r.Project).OrderBy(g => g.Key).ToList();

        sb.AppendLine("### Routes by Area");
        sb.AppendLine();

        foreach (var group in routesByProject)
        {
            sb.AppendLine($"<details>");
            sb.AppendLine($"<summary><strong>{group.Key}</strong> ({group.Count()} routes)</summary>");
            sb.AppendLine();
            sb.AppendLine("| Route | Auth |");
            sb.AppendLine("|-------|:----:|");
            foreach (var route in group.OrderBy(r => r.Route))
            {
                var authIcon = route.RequiresAuth ? "🔐" : "🔓";
                sb.AppendLine($"| `{route.Route}` | {authIcon} |");
            }
            sb.AppendLine();
            sb.AppendLine("</details>");
            sb.AppendLine();
        }

        if (skippedRoutes.Count > 0)
        {
            sb.AppendLine("<details>");
            sb.AppendLine($"<summary><strong>⚠️ Skipped Routes</strong> ({skippedRoutes.Count} routes with parameters)</summary>");
            sb.AppendLine();
            sb.AppendLine("These routes contain parameters (e.g., `{Id}`) and cannot be tested without valid values:");
            sb.AppendLine();
            sb.AppendLine("| Route | Auth |");
            sb.AppendLine("|-------|:----:|");
            foreach (var r in skippedRoutes.OrderBy(x => x.Route))
            {
                var authIcon = r.RequiresAuth ? "🔐" : "🔓";
                sb.AppendLine($"| `{r.Route}` | {authIcon} |");
            }
            sb.AppendLine();
            sb.AppendLine("</details>");
            sb.AppendLine();
        }
    }

    private static async Task GenerateScreenshotGalleryAsync(
        string snapshotsDir, string webProjectRoot, string repoRoot, StringBuilder sb)
    {
        sb.AppendLine("## 📸 Screenshot Gallery");
        sb.AppendLine();

        if (!Directory.Exists(snapshotsDir))
        {
            sb.AppendLine("> Screenshots directory not found. Run PageScreenshoter first.");
            sb.AppendLine();
            return;
        }

        var pngFiles = Directory.GetFiles(snapshotsDir, "*.png", SearchOption.AllDirectories)
            .OrderBy(f => f)
            .ToList();

        if (pngFiles.Count == 0)
        {
            sb.AppendLine("> No screenshots found. Run PageScreenshoter first.");
            sb.AppendLine();
            return;
        }

        sb.AppendLine($"**{pngFiles.Count} page screenshots captured**");
        sb.AppendLine();
        sb.AppendLine("Click on a screenshot to view full size.");
        sb.AppendLine();

        var groupedScreenshots = pngFiles
            .Select(f =>
            {
                var relativePath = Path.GetRelativePath(snapshotsDir, f).Replace('\\', '/');
                var parts = relativePath.Split('/');
                var category = parts.Length > 1 ? parts[0] : "root";
                var route = "/" + string.Join("/", parts.Take(parts.Length - 1));
                if (route == "/root") route = "/";

                // Make path relative to the snapshots directory (where report will be saved alongside)
                // The report file and snapshots folder are siblings, so use snapshots/ prefix
                var imageRelativePath = "snapshots/" + relativePath;

                return new
                {
                    Category = category,
                    Route = route,
                    FullPath = f,
                    RelativePath = imageRelativePath
                };
            })
            .GroupBy(x => x.Category)
            .OrderBy(g => g.Key)
            .ToList();

        foreach (var group in groupedScreenshots)
        {
            var categoryName = group.Key == "root" ? "Home" : group.Key;
            
            sb.AppendLine($"<details open>");
            sb.AppendLine($"<summary><strong>📁 {categoryName}</strong> ({group.Count()} pages)</summary>");
            sb.AppendLine();
            sb.AppendLine("<table>");
            sb.AppendLine("<tr>");

            var itemsInRow = 0;
            foreach (var item in group)
            {
                if (itemsInRow >= 3)
                {
                    sb.AppendLine("</tr>");
                    sb.AppendLine("<tr>");
                    itemsInRow = 0;
                }

                var routeDisplay = ShortenRoute(item.Route, 25);

                sb.AppendLine($"<td align=\"center\" width=\"33%\">");
                sb.AppendLine($"<a href=\"{item.RelativePath}\">");
                sb.AppendLine($"<img src=\"{item.RelativePath}\" width=\"250\" alt=\"{item.Route}\" />");
                sb.AppendLine($"</a>");
                sb.AppendLine($"<br /><code>{routeDisplay}</code>");
                sb.AppendLine($"</td>");

                itemsInRow++;
            }

            while (itemsInRow < 3 && itemsInRow > 0)
            {
                sb.AppendLine("<td></td>");
                itemsInRow++;
            }

            sb.AppendLine("</tr>");
            sb.AppendLine("</table>");
            sb.AppendLine();
            sb.AppendLine("</details>");
            sb.AppendLine();
        }

        await Task.CompletedTask;
    }

    private static FileEntry? ParseCsvLine(string line)
    {
        if (string.IsNullOrWhiteSpace(line)) return null;

        var fields = new List<string>();
        var inQuotes = false;
        var currentField = new StringBuilder();

        foreach (var c in line)
        {
            if (c == '"')
            {
                inQuotes = !inQuotes;
            }
            else if (c == ',' && !inQuotes)
            {
                fields.Add(currentField.ToString());
                currentField.Clear();
            }
            else
            {
                currentField.Append(c);
            }
        }
        fields.Add(currentField.ToString());

        if (fields.Count < 10) return null;

        return new FileEntry
        {
            FilePath = fields[0],
            RelativePath = fields[1],
            Extension = fields[2],
            SizeBytes = long.TryParse(fields[3], out var size) ? size : 0,
            LineCount = long.TryParse(fields[4], out var lines) ? lines : 0,
            CharCount = long.TryParse(fields[5], out var chars) ? chars : 0,
            Kind = fields.Count > 9 ? fields[9] : ""
        };
    }

    private static string GenerateProgressBar(double percentage, int width)
    {
        var filled = (int)(percentage * width / 100.0);
        filled = Math.Clamp(filled, 0, width);
        var empty = width - filled;
        return $"[{'█'.ToString().PadRight(filled, '█')}{'░'.ToString().PadRight(empty, '░')}]";
    }

    private static string ShortenPath(string path, int maxLength)
    {
        if (path.Length <= maxLength) return path;
        return "..." + path[^(maxLength - 3)..];
    }

    private static string ShortenRoute(string route, int maxLength)
    {
        if (route.Length <= maxLength) return route;
        
        var segments = route.Split('/', StringSplitOptions.RemoveEmptyEntries);
        if (segments.Length <= 2)
        {
            return "..." + route[^(maxLength - 3)..];
        }
        
        var first = segments[0];
        var last = segments[^1];
        var shortened = $"/{first}/.../{last}";
        
        if (shortened.Length <= maxLength)
        {
            return shortened;
        }
        
        return $".../{last}";
    }

    private static string FindRepoRoot(string startPath)
    {
        var dir = new DirectoryInfo(startPath);
        while (dir is not null)
        {
            if (Directory.Exists(Path.Combine(dir.FullName, ".git")) ||
                dir.GetFiles("*.sln").Length > 0)
            {
                return dir.FullName;
            }
            dir = dir.Parent;
        }
        return Path.GetFullPath(Path.Combine(startPath, "..", "..", "..", "..", ".."));
    }

    private class FileEntry
    {
        public string FilePath { get; set; } = "";
        public string RelativePath { get; set; } = "";
        public string Extension { get; set; } = "";
        public long SizeBytes { get; set; }
        public long LineCount { get; set; }
        public long CharCount { get; set; }
        public string Kind { get; set; } = "";
    }

    private class RouteEntry
    {
        public string Route { get; set; } = "";
        public bool RequiresAuth { get; set; }
        public string Project { get; set; } = "";
    }

    private class WorkspaceStats
    {
        public int TotalFiles { get; set; }
        public long TotalLines { get; set; }
        public long TotalSize { get; set; }
    }
}
