using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using FreeTools.Core;

namespace FreeTools.WorkspaceReporter;

internal partial class Program
{
    private static async Task<int> Main(string[] args)
    {
        // Robustness: Optional startup delay
        var delayEnv = Environment.GetEnvironmentVariable("START_DELAY_MS");
        if (int.TryParse(delayEnv, out var delayMs) && delayMs > 0)
        {
            Console.WriteLine($"Delaying start by {delayMs} ms...");
            await Task.Delay(delayMs);
        }

        ConsoleOutput.PrintBanner("WorkspaceReporter (FreeTools)", "1.0");

        var repoRoot = Environment.GetEnvironmentVariable("REPO_ROOT")
            ?? CliArgs.GetPositional(args.ToList(), 0)
            ?? FindRepoRoot(AppContext.BaseDirectory);

        if (string.IsNullOrEmpty(repoRoot) || !Directory.Exists(repoRoot))
        {
            Console.Error.WriteLine($"Repository root not found: {repoRoot}");
            return 1;
        }

        repoRoot = Path.GetFullPath(repoRoot);

        var outputPath = Environment.GetEnvironmentVariable("OUTPUT_PATH")
            ?? CliArgs.GetPositional(args.ToList(), 1)
            ?? Path.Combine(repoRoot, "LatestReport.md");

        var workspaceCsv = Environment.GetEnvironmentVariable("WORKSPACE_CSV")
            ?? Path.Combine(repoRoot, "workspace-inventory.csv");
        var workspaceCsharpCsv = Environment.GetEnvironmentVariable("WORKSPACE_CSHARP_CSV")
            ?? Path.Combine(repoRoot, "workspace-inventory-csharp.csv");
        var workspaceRazorCsv = Environment.GetEnvironmentVariable("WORKSPACE_RAZOR_CSV")
            ?? Path.Combine(repoRoot, "workspace-inventory-razor.csv");

        var webProjectRoot = Environment.GetEnvironmentVariable("WEB_PROJECT_ROOT")
            ?? Path.Combine(repoRoot, "Web", "FreeTools.Web");

        var pagesCsv = Environment.GetEnvironmentVariable("PAGES_CSV")
            ?? Path.Combine(webProjectRoot, "pages.csv");
        var snapshotsDir = Environment.GetEnvironmentVariable("SNAPSHOTS_DIR")
            ?? Path.Combine(webProjectRoot, "page-snapshots");
        
        // Get target project name for building correct GitHub links
        // Report is at: Docs/runs/{Project}/{Branch}/latest/Report.md
        // Target files are at: ../{Project}/...
        // So relative path from report to target is: ../../../../../../{Project}/
        var targetProject = Environment.GetEnvironmentVariable("TARGET_PROJECT")
            ?? Path.GetFileName(repoRoot);

        ConsoleOutput.PrintConfig("Repo Root", repoRoot);
        ConsoleOutput.PrintConfig("Output Path", outputPath);
        ConsoleOutput.PrintConfig("Workspace CSV", workspaceCsv);
        ConsoleOutput.PrintConfig("Pages CSV", pagesCsv);
        ConsoleOutput.PrintConfig("Snapshots Dir", snapshotsDir);
        ConsoleOutput.PrintConfig("Target Project", targetProject);
        ConsoleOutput.PrintDivider();
        Console.WriteLine();

        var sb = new StringBuilder();

        sb.AppendLine("# 📊 FreeTools Workspace Report");
        sb.AppendLine();
        sb.AppendLine($"> **Generated:** {DateTime.Now:yyyy-MM-dd HH:mm:ss}  ");
        sb.AppendLine($"> **Repository:** {Path.GetFileName(repoRoot)}  ");
        sb.AppendLine($"> **Scope:** Blazor pages only — API endpoints not included  ");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();

        sb.AppendLine("## 📑 Table of Contents");
        sb.AppendLine();
        sb.AppendLine("- [About This Report](#-about-this-report)");
        sb.AppendLine("- [Workspace Overview](#-workspace-overview)");
        sb.AppendLine("- [File Statistics](#-file-statistics)");
        sb.AppendLine("- [Code Distribution](#-code-distribution)");
        sb.AppendLine("- [Largest Files](#-largest-files)");
        sb.AppendLine("- [Large File Warnings](#%EF%B8%8F-large-file-warnings)");
        sb.AppendLine("- [Blazor Page Routes](#%EF%B8%8F-blazor-page-routes)");
        sb.AppendLine("- [Route Map](#-route-map)");
        sb.AppendLine("- [Screenshot Health](#-screenshot-health)");
        sb.AppendLine("- [Screenshot Gallery](#-screenshot-gallery)");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();

        sb.AppendLine("## 📋 About This Report");
        sb.AppendLine();
        sb.AppendLine("This report is auto-generated by the **WorkspaceReporter** tool pipeline.");
        sb.AppendLine();
        sb.AppendLine("### Scope");
        sb.AppendLine();
        sb.AppendLine("| Included | Not Included |");
        sb.AppendLine("|----------|--------------|");
        sb.AppendLine("| ✅ Blazor pages (`@page` directives) | ❌ API endpoints (`/api/*`) |");
        sb.AppendLine("| ✅ Razor components | ❌ Dynamic routes (MapGet/MapPost) |");
        sb.AppendLine("| ✅ C# source files | ❌ Routes with parameters (`{id}`) |");
        sb.AppendLine("| ✅ Configuration files | |");
        sb.AppendLine();
        sb.AppendLine("### File Categories (Kind)");
        sb.AppendLine();
        sb.AppendLine("| Kind | Description |");
        sb.AppendLine("|------|-------------|");
        sb.AppendLine("| **RazorPage** | `.razor` file with `@page` directive (routable) |");
        sb.AppendLine("| **RazorComponent** | `.razor` file without `@page` (reusable component) |");
        sb.AppendLine("| **CSharpSource** | `.cs` file (classes, services, etc.) |");
        sb.AppendLine("| **ProjectFile** | `.csproj` file (project configuration) |");
        sb.AppendLine("| **SolutionFile** | `.sln` file (solution configuration) |");
        sb.AppendLine("| **Config** | `.json`, `.xml`, `.yaml`, `.yml`, `.config` files |");
        sb.AppendLine("| **Markdown** | `.md` documentation files |");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();

        Console.WriteLine("Processing workspace inventory...");
        var workspaceStats = await ProcessWorkspaceInventoryAsync(workspaceCsv, workspaceCsharpCsv, workspaceRazorCsv, sb, targetProject);

        Console.WriteLine("Processing pages CSV...");
        await ProcessPagesCsvAsync(pagesCsv, sb);

        Console.WriteLine("Processing screenshot health...");
        await GenerateScreenshotHealthAsync(snapshotsDir, sb);

        Console.WriteLine("Generating screenshot gallery...");
        await GenerateScreenshotGalleryAsync(snapshotsDir, webProjectRoot, repoRoot, sb);

        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("## 🔧 Tool Information");
        sb.AppendLine();
        sb.AppendLine("This report was generated by the **WorkspaceReporter** tool, which aggregates outputs from:");
        sb.AppendLine();
        sb.AppendLine("| Tool | Purpose |");
        sb.AppendLine("|------|---------|");
        sb.AppendLine("| **WorkspaceInventory** | Scans codebase, extracts metrics and classifications |");
        sb.AppendLine("| **EndpointMapper** | Discovers Blazor routes from `@page` directives |");
        sb.AppendLine("| **EndpointPoker** | Performs HTTP GET requests to verify routes |");
        sb.AppendLine("| **BrowserSnapshot** | Captures full-page screenshots with Playwright |");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine("**[FreeTools](https://github.com/WSU-EIT/FreeTools)** — Open source workspace analysis tools for .NET projects");
        sb.AppendLine();
        sb.AppendLine("Developed by [Enrollment Information Technology](https://em.wsu.edu/eit/meet-our-staff/) at Washington State University");
        sb.AppendLine();

        Console.WriteLine();
        Console.WriteLine($"Writing report to: {outputPath}");
        
        var outputDir = Path.GetDirectoryName(outputPath);
        if (!string.IsNullOrEmpty(outputDir) && !Directory.Exists(outputDir))
        {
            Directory.CreateDirectory(outputDir);
        }

        await File.WriteAllTextAsync(outputPath, sb.ToString(), Encoding.UTF8);

        Console.WriteLine();
        Console.WriteLine("============================================================");
        Console.WriteLine("                    REPORT COMPLETE");
        Console.WriteLine("============================================================");
        Console.WriteLine($"  Output: {outputPath}");
        Console.WriteLine($"  Size: {new FileInfo(outputPath).Length:N0} bytes");
        Console.WriteLine("============================================================");

        return 0;
    }

    private static async Task<WorkspaceStats> ProcessWorkspaceInventoryAsync(
        string workspaceCsv, string csharpCsv, string razorCsv, StringBuilder sb, string targetProject)
    {
        var stats = new WorkspaceStats();

        if (!File.Exists(workspaceCsv))
        {
            sb.AppendLine("## ⚠️ Workspace Overview");
            sb.AppendLine();
            sb.AppendLine("> Workspace inventory CSV not found. Run WorkspaceInventory first.");
            sb.AppendLine();
            return stats;
        }

        var lines = await File.ReadAllLinesAsync(workspaceCsv);
        if (lines.Length < 2)
        {
            sb.AppendLine("## ⚠️ Workspace Overview");
            sb.AppendLine();
            sb.AppendLine("> Workspace inventory CSV is empty.");
            sb.AppendLine();
            return stats;
        }

        var files = new List<FileEntry>();
        var kindCounts = new Dictionary<string, int>();
        var extensionCounts = new Dictionary<string, int>();
        long totalLines = 0;
        long totalChars = 0;
        long totalSize = 0;

        for (int i = 1; i < lines.Length; i++)
        {
            var entry = ParseCsvLine(lines[i]);
            if (entry is null) continue;

            files.Add(entry);
            totalSize += entry.SizeBytes;
            totalLines += entry.LineCount;
            totalChars += entry.CharCount;

            if (!string.IsNullOrEmpty(entry.Kind))
            {
                kindCounts.TryGetValue(entry.Kind, out var kc);
                kindCounts[entry.Kind] = kc + 1;
            }

            if (!string.IsNullOrEmpty(entry.Extension))
            {
                extensionCounts.TryGetValue(entry.Extension, out var ec);
                extensionCounts[entry.Extension] = ec + 1;
            }
        }

        stats.TotalFiles = files.Count;
        stats.TotalLines = totalLines;
        stats.TotalSize = totalSize;

        // Calculate averages
        var avgLinesPerFile = files.Count > 0 ? (double)totalLines / files.Count : 0;
        var avgSizePerFile = files.Count > 0 ? (double)totalSize / files.Count : 0;

        sb.AppendLine("## 📁 Workspace Overview");
        sb.AppendLine();
        sb.AppendLine("| Metric | Value |");
        sb.AppendLine("|--------|-------|");
        sb.AppendLine($"| **Total Files** | {files.Count:N0} |");
        sb.AppendLine($"| **Total Lines** | {totalLines:N0} |");
        sb.AppendLine($"| **Total Characters** | {totalChars:N0} |");
        sb.AppendLine($"| **Total Size** | {PathSanitizer.FormatBytes(totalSize)} |");
        sb.AppendLine($"| **Avg Lines/File** | {avgLinesPerFile:F1} |");
        sb.AppendLine($"| **Avg Size/File** | {PathSanitizer.FormatBytes((long)avgSizePerFile)} |");
        sb.AppendLine();

        sb.AppendLine("## 📈 File Statistics");
        sb.AppendLine();
        sb.AppendLine("### By Category");
        sb.AppendLine();
        sb.AppendLine("| Category | Count | Avg Lines | Total Lines | Percentage |");
        sb.AppendLine("|----------|------:|----------:|------------:|------------|");

        foreach (var kvp in kindCounts.OrderByDescending(k => k.Value))
        {
            var pct = files.Count > 0 ? (kvp.Value * 100.0 / files.Count) : 0;
            var bar = GenerateProgressBar(pct, 20);
            var categoryFiles = files.Where(f => f.Kind == kvp.Key).ToList();
            var categoryTotalLines = categoryFiles.Sum(f => f.LineCount);
            var categoryAvgLines = categoryFiles.Count > 0 ? (double)categoryTotalLines / categoryFiles.Count : 0;
            sb.AppendLine($"| {kvp.Key} | {kvp.Value:N0} | {categoryAvgLines:F0} | {categoryTotalLines:N0} | {bar} {pct:F1}% |");
        }
        sb.AppendLine();

        // Add expandable file lists for each category
        sb.AppendLine("### Files by Category");
        sb.AppendLine();
        
        var filesByKind = files
            .GroupBy(f => f.Kind ?? "Unknown")
            .OrderByDescending(g => g.Count())
            .ToList();

        foreach (var group in filesByKind)
        {
            sb.AppendLine($"<details>");
            sb.AppendLine($"<summary><strong>{group.Key}</strong> ({group.Count()} files)</summary>");
            sb.AppendLine();
            sb.AppendLine("| File | Lines | Size |");
            sb.AppendLine("|------|------:|-----:|");
            
            foreach (var file in group.OrderBy(f => f.RelativePath))
            {
                // Create a relative link that works on GitHub (from report location to source file)
                // Report is at: Docs/runs/{Project}/{Branch}/latest/Report.md
                // Target is at: {targetProject}/...
                // Relative: ../../../../../../{targetProject}/...
                var linkPath = file.RelativePath.Replace('\\', '/');
                var displayPath = ShortenPath(file.RelativePath, 60);
                sb.AppendLine($"| [{displayPath}](../../../../../../{targetProject}/{linkPath}) | {file.LineCount:N0} | {PathSanitizer.FormatBytes(file.SizeBytes)} |");
            }
            
            sb.AppendLine();
            sb.AppendLine("</details>");
            sb.AppendLine();
        }

        sb.AppendLine("## 📊 Code Distribution");
        sb.AppendLine();
        sb.AppendLine("### Lines of Code by Category");
        sb.AppendLine();
        sb.AppendLine("```");

        var linesByKind = files
            .GroupBy(f => f.Kind ?? "Unknown")
            .Select(g => new { Kind = g.Key, Lines = g.Sum(f => f.LineCount) })
            .OrderByDescending(x => x.Lines)
            .ToList();

        var maxLines = linesByKind.FirstOrDefault()?.Lines ?? 1;
        foreach (var item in linesByKind)
        {
            var barWidth = (int)(item.Lines * 40.0 / maxLines);
            var bar = new string('█', Math.Max(1, barWidth));
            sb.AppendLine($"{item.Kind,-20} {bar} {item.Lines:N0}");
        }
        sb.AppendLine("```");
        sb.AppendLine();

        sb.AppendLine("### By Extension");
        sb.AppendLine();
        sb.AppendLine("```");
        var maxExtCount = extensionCounts.Values.DefaultIfEmpty(1).Max();
        foreach (var kvp in extensionCounts.OrderByDescending(k => k.Value).Take(10))
        {
            var barWidth = (int)(kvp.Value * 30.0 / maxExtCount);
            var bar = new string('█', Math.Max(1, barWidth));
            sb.AppendLine($"{kvp.Key,-10} {bar} {kvp.Value:N0}");
        }
        sb.AppendLine("```");
        sb.AppendLine();

        sb.AppendLine("## 📏 Largest Files");
        sb.AppendLine();
        sb.AppendLine("### Top 15 C# Files by Line Count");
        sb.AppendLine();

        var topCsFiles = files
            .Where(f => f.Extension == ".cs")
            .OrderByDescending(f => f.LineCount)
            .Take(15)
            .ToList();

        if (topCsFiles.Count > 0)
        {
            sb.AppendLine("| # | File | Lines | Size |");
            sb.AppendLine("|--:|------|------:|-----:|");
            for (int i = 0; i < topCsFiles.Count; i++)
            {
                var f = topCsFiles[i];
                var linkPath = f.RelativePath.Replace('\\', '/');
                var displayPath = ShortenPath(f.RelativePath, 50);
                sb.AppendLine($"| {i + 1} | [{displayPath}](../../../../../../{targetProject}/{linkPath}) | {f.LineCount:N0} | {PathSanitizer.FormatBytes(f.SizeBytes)} |");
            }
        }
        else
        {
            sb.AppendLine("> No C# files found.");
        }
        sb.AppendLine();

        sb.AppendLine("### Top 15 Razor Files by Line Count");
        sb.AppendLine();

        var topRazorFiles = files
            .Where(f => f.Extension == ".razor")
            .OrderByDescending(f => f.LineCount)
            .Take(15)
            .ToList();

        if (topRazorFiles.Count > 0)
        {
            sb.AppendLine("| # | File | Lines | Kind |");
            sb.AppendLine("|--:|------|------:|------|");
            for (int i = 0; i < topRazorFiles.Count; i++)
            {
                var f = topRazorFiles[i];
                var linkPath = f.RelativePath.Replace('\\', '/');
                var displayPath = ShortenPath(f.RelativePath, 50);
                sb.AppendLine($"| {i + 1} | [{displayPath}](../../../../../../{targetProject}/{linkPath}) | {f.LineCount:N0} | {f.Kind} |");
            }
        }
        else
        {
            sb.AppendLine("> No Razor files found.");
        }
        sb.AppendLine();

        // Large File Warnings - based on LLM-friendly file sizes
        // LLMs read in ~150 line increments, so 150-450 is ideal (2-3 reads)
        const int NoticeThreshold = 450;    // Starting to get long
        const int WarningThreshold = 600;   // Too long for comfortable LLM processing  
        const int CriticalThreshold = 900;  // Way too long
        
        var largeFiles = files
            .Where(f => f.LineCount > NoticeThreshold)
            .OrderByDescending(f => f.LineCount)
            .ToList();

        sb.AppendLine("## ⚠️ Large File Warnings");
        sb.AppendLine();
        sb.AppendLine("> **LLM-Friendly File Size Guide:**");
        sb.AppendLine("> - ✅ **Ideal:** 0-450 lines (1-3 LLM reads at ~150 lines each)");
        sb.AppendLine("> - 🟡 **Notice:** 450-600 lines (getting long)");
        sb.AppendLine("> - 🟠 **Warning:** 600-900 lines (too long)");
        sb.AppendLine("> - 🔴 **Critical:** >900 lines (should split)");
        sb.AppendLine();

        if (largeFiles.Count > 0)
        {
            sb.AppendLine($"**{largeFiles.Count} files** exceed the ideal threshold of {NoticeThreshold} lines:");
            sb.AppendLine();
            sb.AppendLine("| File | Lines | Kind | Severity | Recommendation |");
            sb.AppendLine("|------|------:|------|:--------:|----------------|");

            foreach (var f in largeFiles)
            {
                var linkPath = f.RelativePath.Replace('\\', '/');
                var displayPath = ShortenPath(f.RelativePath, 40);
                var recommendation = GetRefactoringRecommendation(f);
                var (icon, severity) = f.LineCount switch
                {
                    > 900 => ("🔴", "Critical"),
                    > 600 => ("🟠", "Warning"),
                    _ => ("🟡", "Notice")
                };
                sb.AppendLine($"| [{displayPath}](../../../../../../{targetProject}/{linkPath}) | {f.LineCount:N0} | {f.Kind} | {icon} {severity} | {recommendation} |");
            }
            sb.AppendLine();

            // Summary by severity
            var critical = largeFiles.Count(f => f.LineCount > CriticalThreshold);
            var warning = largeFiles.Count(f => f.LineCount > WarningThreshold && f.LineCount <= CriticalThreshold);
            var notice = largeFiles.Count(f => f.LineCount <= WarningThreshold);

            sb.AppendLine("### Severity Summary");
            sb.AppendLine();
            sb.AppendLine("| Severity | Count | Description |");
            sb.AppendLine("|----------|------:|-------------|");
            sb.AppendLine($"| 🔴 Critical | {critical} | >900 lines — strongly consider splitting |");
            sb.AppendLine($"| 🟠 Warning | {warning} | 600-900 lines — review for refactoring |");
            sb.AppendLine($"| 🟡 Notice | {notice} | 450-600 lines — monitor for growth |");
            sb.AppendLine();

            // Add ideal file stats
            var idealFiles = files.Count(f => f.LineCount <= NoticeThreshold);
            var idealPct = files.Count > 0 ? (idealFiles * 100.0 / files.Count) : 0;
            sb.AppendLine($"**{idealFiles} of {files.Count} files ({idealPct:F0}%)** are within the ideal range (≤{NoticeThreshold} lines).");
        }
        else
        {
            var idealFiles = files.Count(f => f.LineCount <= NoticeThreshold);
            var idealPct = files.Count > 0 ? (idealFiles * 100.0 / files.Count) : 0;
            sb.AppendLine($"✅ **Excellent!** All files are under {NoticeThreshold} lines.");
            sb.AppendLine();
            sb.AppendLine($"**{idealFiles} of {files.Count} files ({idealPct:F0}%)** are within the ideal LLM-friendly range.");
        }
        sb.AppendLine();

        return stats;
    }

    private static string GetRefactoringRecommendation(FileEntry file)
    {
        if (file.Kind == "RazorPage" && file.LineCount > 600)
            return "Extract components urgently";
        if (file.Kind == "RazorPage" && file.LineCount > 450)
            return "Consider extracting components";
        if (file.Kind == "CSharpSource" && file.RelativePath.Contains("Migration"))
            return "Auto-generated (OK)";
        if (file.Kind == "CSharpSource" && file.LineCount > 900)
            return "Split into multiple services";
        if (file.Kind == "CSharpSource" && file.LineCount > 600)
            return "Consider splitting into services";
        if (file.Kind == "CSharpSource")
            return "Review for single responsibility";
        if (file.Kind == "RazorComponent" && file.LineCount > 450)
            return "Split into smaller components";
        return "Review for refactoring opportunities";
    }

    private static async Task ProcessPagesCsvAsync(string pagesCsv, StringBuilder sb)
    {
        sb.AppendLine("## 🛤️ Blazor Page Routes");
        sb.AppendLine();
        sb.AppendLine("> **Note:** This section shows Blazor pages with `@page` directives only.");
        sb.AppendLine("> API endpoints (`/api/*`) are not included. Routes with parameters are skipped.");
        sb.AppendLine();

        if (!File.Exists(pagesCsv))
        {
            sb.AppendLine("> Pages CSV not found. Run PageScanner first.");
            sb.AppendLine();
            return;
        }

        var lines = await File.ReadAllLinesAsync(pagesCsv);
        if (lines.Length < 2)
        {
            sb.AppendLine("> Pages CSV is empty.");
            sb.AppendLine();
            return;
        }

        var routes = new List<RouteEntry>();
        var skippedRoutes = new List<RouteEntry>();
        var authRequired = 0;
        var publicRoutes = 0;

        for (int i = 1; i < lines.Length; i++)
        {
            var parts = lines[i].Split(',');
            if (parts.Length < 4) continue;

            var route = parts[1].Trim('"').Trim();
            var requiresAuth = parts[2].Trim().ToLower() == "true";
            var project = parts[3].Trim('"').Trim();

            if (string.IsNullOrEmpty(route)) continue;

            var entry = new RouteEntry
            {
                Route = route,
                RequiresAuth = requiresAuth,
                Project = project
            };

            if (RouteParser.HasParameter(route))
            {
                skippedRoutes.Add(entry);
                continue;
            }

            routes.Add(entry);

            if (requiresAuth)
                authRequired++;
            else
                publicRoutes++;
        }

        sb.AppendLine("### Route Summary");
        sb.AppendLine();
        sb.AppendLine("| Metric | Count |");
        sb.AppendLine("|--------|------:|");
        sb.AppendLine($"| **Testable Routes** | {routes.Count} |");
        sb.AppendLine($"| **Public Routes** | {publicRoutes} |");
        sb.AppendLine($"| **Auth Required** | {authRequired} |");
        sb.AppendLine($"| **Skipped (parameters)** | {skippedRoutes.Count} |");
        sb.AppendLine();

        if (routes.Count > 0)
        {
            var publicPct = publicRoutes * 100.0 / routes.Count;
            var authPct = authRequired * 100.0 / routes.Count;

            sb.AppendLine("### Access Distribution");
            sb.AppendLine();
            sb.AppendLine("```");
            sb.AppendLine($"🔓 Public:     {GenerateProgressBar(publicPct, 30)} {publicPct:F0}%");
            sb.AppendLine($"🔐 Protected:  {GenerateProgressBar(authPct, 30)} {authPct:F0}%");
            sb.AppendLine("```");
            sb.AppendLine();
        }

        var routesByProject = routes.GroupBy(r => r.Project).OrderBy(g => g.Key).ToList();

        sb.AppendLine("### Routes by Area");
        sb.AppendLine();

        foreach (var group in routesByProject)
        {
            sb.AppendLine($"<details>");
            sb.AppendLine($"<summary><strong>{group.Key}</strong> ({group.Count()} routes)</summary>");
            sb.AppendLine();
            sb.AppendLine("| Route | Auth |");
            sb.AppendLine("|-------|:----:|");
            foreach (var route in group.OrderBy(r => r.Route))
            {
                var authIcon = route.RequiresAuth ? "🔐" : "🔓";
                sb.AppendLine($"| `{route.Route}` | {authIcon} |");
            }
            sb.AppendLine();
            sb.AppendLine("</details>");
            sb.AppendLine();
        }

        if (skippedRoutes.Count > 0)
        {
            sb.AppendLine("<details>");
            sb.AppendLine($"<summary><strong>⚠️ Skipped Routes</strong> ({skippedRoutes.Count} routes with parameters)</summary>");
            sb.AppendLine();
            sb.AppendLine("These routes contain parameters (e.g., `{Id}`) and cannot be tested without valid values:");
            sb.AppendLine();
            sb.AppendLine("| Route | Auth |");
            sb.AppendLine("|-------|:----:|");
            foreach (var r in skippedRoutes.OrderBy(x => x.Route))
            {
                var authIcon = r.RequiresAuth ? "🔐" : "🔓";
                sb.AppendLine($"| `{r.Route}` | {authIcon} |");
            }
            sb.AppendLine();
            sb.AppendLine("</details>");
            sb.AppendLine();
        }

        // Generate Mermaid Route Map
        GenerateRouteMap(routes.Concat(skippedRoutes).ToList(), sb);
    }

    private static void GenerateRouteMap(List<RouteEntry> allRoutes, StringBuilder sb)
    {
        sb.AppendLine("## 🗺️ Route Map");
        sb.AppendLine();
        sb.AppendLine("> Visual representation of the route hierarchy. GitHub renders this as an interactive diagram.");
        sb.AppendLine();
        sb.AppendLine("```mermaid");
        sb.AppendLine("graph TD");
        
        // Build a tree structure
        var nodeId = 0;
        var nodeMap = new Dictionary<string, string>(); // path -> node id
        
        // Root node
        sb.AppendLine("    ROOT[(\"/\")]");
        nodeMap["/"] = "ROOT";

        // Sort routes and build tree
        var sortedRoutes = allRoutes.OrderBy(r => r.Route).ToList();
        
        foreach (var route in sortedRoutes)
        {
            var segments = route.Route.Trim('/').Split('/', StringSplitOptions.RemoveEmptyEntries);
            if (segments.Length == 0) continue;

            var currentPath = "";
            var parentNode = "ROOT";

            for (int i = 0; i < segments.Length; i++)
            {
                var segment = segments[i];
                var isLast = i == segments.Length - 1;
                currentPath += "/" + segment;

                if (!nodeMap.ContainsKey(currentPath))
                {
                    nodeId++;
                    var newNodeId = $"N{nodeId}";
                    nodeMap[currentPath] = newNodeId;

                    // Determine node style
                    var hasParam = segment.Contains('{');
                    var isAuthRequired = isLast && route.RequiresAuth;

                    string nodeLabel;
                    if (hasParam)
                    {
                        nodeLabel = $"{newNodeId}[[\"{segment}\"]]"; // Double bracket for parameters
                    }
                    else if (isLast && isAuthRequired)
                    {
                        nodeLabel = $"{newNodeId}[🔐 {segment}]";
                    }
                    else if (isLast)
                    {
                        nodeLabel = $"{newNodeId}[{segment}]";
                    }
                    else
                    {
                        nodeLabel = $"{newNodeId}({segment})"; // Rounded for intermediate
                    }

                    sb.AppendLine($"    {parentNode} --> {nodeLabel}");
                }

                parentNode = nodeMap[currentPath];
            }
        }

        // Add styling
        sb.AppendLine();
        sb.AppendLine("    classDef authPage fill:#ff6b6b,stroke:#333,stroke-width:2px");
        sb.AppendLine("    classDef paramRoute fill:#ffd93d,stroke:#333,stroke-width:2px");
        
        // Apply styles to auth nodes
        var authNodes = allRoutes
            .Where(r => r.RequiresAuth)
            .Select(r => nodeMap.GetValueOrDefault("/" + r.Route.Trim('/').Split('/').Last()))
            .Where(n => n != null)
            .ToList();
        
        if (authNodes.Count > 0)
        {
            sb.AppendLine($"    class {string.Join(",", authNodes)} authPage");
        }

        sb.AppendLine("```");
        sb.AppendLine();

        // Route depth analysis
        var routeDepths = allRoutes
            .Select(r => new { Route = r, Depth = r.Route.Trim('/').Split('/', StringSplitOptions.RemoveEmptyEntries).Length })
            .GroupBy(x => x.Depth)
            .OrderBy(g => g.Key)
            .ToList();

        sb.AppendLine("### Route Depth Analysis");
        sb.AppendLine();
        sb.AppendLine("| Depth | Count | Routes |");
        sb.AppendLine("|------:|------:|--------|");

        foreach (var group in routeDepths)
        {
            var routeList = string.Join(", ", group.Take(3).Select(x => $"`{x.Route.Route}`"));
            if (group.Count() > 3)
            {
                routeList += $" +{group.Count() - 3} more";
            }
            sb.AppendLine($"| {group.Key} | {group.Count()} | {routeList} |");
        }
        sb.AppendLine();
    }

    private static async Task GenerateScreenshotHealthAsync(string snapshotsDir, StringBuilder sb)
    {
        sb.AppendLine("## 📊 Screenshot Health");
        sb.AppendLine();

        if (!Directory.Exists(snapshotsDir))
        {
            sb.AppendLine("> Screenshots directory not found. Run BrowserSnapshot first.");
            sb.AppendLine();
            return;
        }

        // Find all metadata.json files
        var metadataFiles = Directory.GetFiles(snapshotsDir, "metadata.json", SearchOption.AllDirectories)
            .OrderBy(f => f)
            .ToList();

        if (metadataFiles.Count == 0)
        {
            sb.AppendLine("> No screenshot metadata found. Run BrowserSnapshot v2.1+ to generate metadata files.");
            sb.AppendLine();
            return;
        }

        // Parse all metadata
        List<ScreenshotHealthEntry> entries = [];
        foreach (var metadataFile in metadataFiles)
        {
            try
            {
                var json = await File.ReadAllTextAsync(metadataFile);
                var metadata = JsonSerializer.Deserialize<ScreenshotHealthEntry>(json, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });
                if (metadata != null)
                {
                    entries.Add(metadata);
                }
            }
            catch
            {
                // Skip invalid metadata files
            }
        }

        if (entries.Count == 0)
        {
            sb.AppendLine("> Could not parse any metadata files.");
            sb.AppendLine();
            return;
        }

        // Calculate statistics
        var successCount = entries.Count(e => e.IsSuccess && !e.IsSuspiciouslySmall);
        var suspiciousCount = entries.Count(e => e.IsSuspiciouslySmall);
        var retriedCount = entries.Count(e => e.RetryAttempted);
        var httpErrorCount = entries.Count(e => e.IsHttpError);
        var errorCount = entries.Count(e => e.IsError);
        var jsErrorCount = entries.Count(e => e.ConsoleErrors?.Count > 0);
        
        // Auth flow statistics
        var authRequiredCount = entries.Count(e => e.RequiresAuth);
        var authFlowCompletedCount = entries.Count(e => e.AuthFlowCompleted);
        var publicCount = entries.Count - authRequiredCount;

        sb.AppendLine("| Status | Count | Description |");
        sb.AppendLine("|--------|------:|-------------|");
        sb.AppendLine($"| ✅ Success | {successCount} | Screenshots > 10KB |");
        sb.AppendLine($"| 🔓 Public | {publicCount} | Single screenshot pages |");
        sb.AppendLine($"| 🔐 Auth Required | {authRequiredCount} | Pages requiring login |");
        sb.AppendLine($"| ✅ Auth Flow OK | {authFlowCompletedCount} | Login flow completed |");
        sb.AppendLine($"| ⚠️ Suspicious | {suspiciousCount} | Screenshots < 10KB (possible blank) |");
        sb.AppendLine($"| 🔄 Retried | {retriedCount} | Required retry attempt |");
        sb.AppendLine($"| ❌ HTTP Error | {httpErrorCount} | 4xx/5xx responses |");
        sb.AppendLine($"| 💥 Failed | {errorCount} | Browser/timeout errors |");
        sb.AppendLine($"| 🔴 JS Errors | {jsErrorCount} | Pages with console errors |");
        sb.AppendLine();

        // Suspicious screenshots details
        var suspicious = entries.Where(e => e.IsSuspiciouslySmall).ToList();
        if (suspicious.Count > 0)
        {
            sb.AppendLine("<details>");
            sb.AppendLine($"<summary>⚠️ <strong>Suspicious Screenshots</strong> ({suspicious.Count})</summary>");
            sb.AppendLine();
            sb.AppendLine("| Route | Size | Status | JS Errors |");
            sb.AppendLine("|-------|-----:|:------:|----------:|");
            foreach (var entry in suspicious.OrderBy(e => e.Route))
            {
                var size = PathSanitizer.FormatBytes(entry.FileSize);
                var status = entry.RetryAttempted ? "🔄 Retried" : "⚠️";
                var jsErrors = entry.ConsoleErrors?.Count ?? 0;
                sb.AppendLine($"| `{entry.Route}` | {size} | {status} | {jsErrors} |");
            }
            sb.AppendLine();
            sb.AppendLine("</details>");
            sb.AppendLine();
        }

        // HTTP errors details
        var httpErrors = entries.Where(e => e.IsHttpError).ToList();
        if (httpErrors.Count > 0)
        {
            sb.AppendLine("<details>");
            sb.AppendLine($"<summary>❌ <strong>HTTP Errors</strong> ({httpErrors.Count})</summary>");
            sb.AppendLine();
            sb.AppendLine("| Route | Status Code |");
            sb.AppendLine("|-------|------------:|");
            foreach (var entry in httpErrors.OrderBy(e => e.Route))
            {
                sb.AppendLine($"| `{entry.Route}` | {entry.StatusCode} |");
            }
            sb.AppendLine();
            sb.AppendLine("</details>");
            sb.AppendLine();
        }

        // JS errors details
        var withJsErrors = entries.Where(e => e.ConsoleErrors?.Count > 0).ToList();
        if (withJsErrors.Count > 0)
        {
            sb.AppendLine("<details>");
            sb.AppendLine($"<summary>🔴 <strong>Pages with JavaScript Errors</strong> ({withJsErrors.Count})</summary>");
            sb.AppendLine();
            foreach (var entry in withJsErrors.OrderBy(e => e.Route))
            {
                sb.AppendLine($"**`{entry.Route}`** ({entry.ConsoleErrors!.Count} errors)");
                sb.AppendLine();
                sb.AppendLine("```");
                foreach (var error in entry.ConsoleErrors.Take(5))
                {
                    var errorMsg = error.Length > 200 ? error[..200] + "..." : error;
                    sb.AppendLine(errorMsg);
                }
                if (entry.ConsoleErrors.Count > 5)
                {
                    sb.AppendLine($"... and {entry.ConsoleErrors.Count - 5} more errors");
                }
                sb.AppendLine("```");
                sb.AppendLine();
            }
            sb.AppendLine("</details>");
            sb.AppendLine();
        }

        // Success rate
        var totalAttempted = entries.Count;
        var successRate = totalAttempted > 0 ? (successCount * 100.0 / totalAttempted) : 0;
        sb.AppendLine($"**Overall Success Rate:** {successRate:F0}% ({successCount}/{totalAttempted} pages captured cleanly)");
        sb.AppendLine();
    }

    private static async Task GenerateScreenshotGalleryAsync(
        string snapshotsDir, string webProjectRoot, string repoRoot, StringBuilder sb)
    {
        sb.AppendLine("## 📸 Screenshot Gallery");
        sb.AppendLine();

        if (!Directory.Exists(snapshotsDir))
        {
            sb.AppendLine("> Screenshots directory not found. Run BrowserSnapshot first.");
            sb.AppendLine();
            return;
        }

        // Load metadata files to understand auth flow
        var metadataFiles = Directory.GetFiles(snapshotsDir, "metadata.json", SearchOption.AllDirectories)
            .OrderBy(f => f)
            .ToList();

        // Build a dictionary of route -> metadata
        var routeMetadata = new Dictionary<string, ScreenshotHealthEntry>();
        foreach (var metadataFile in metadataFiles)
        {
            try
            {
                var json = await File.ReadAllTextAsync(metadataFile);
                var metadata = System.Text.Json.JsonSerializer.Deserialize<ScreenshotHealthEntry>(json, 
                    new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                if (metadata != null && !string.IsNullOrEmpty(metadata.Route))
                {
                    routeMetadata[metadata.Route] = metadata;
                }
            }
            catch { /* Skip invalid metadata */ }
        }

        // Group screenshots by route directory
        var allRoutes = Directory.GetDirectories(snapshotsDir, "*", SearchOption.AllDirectories)
            .Where(d => Directory.GetFiles(d, "*.png").Length > 0)
            .Concat(new[] { snapshotsDir })
            .Where(d => Directory.GetFiles(d, "*.png").Length > 0)
            .Select(d =>
            {
                var relativePath = d == snapshotsDir ? "" : Path.GetRelativePath(snapshotsDir, d).Replace('\\', '/');
                var route = string.IsNullOrEmpty(relativePath) ? "/" : "/" + relativePath;
                var category = relativePath.Contains('/') ? relativePath.Split('/')[0] : 
                              (string.IsNullOrEmpty(relativePath) ? "root" : relativePath);
                
                return new RouteScreenshots
                {
                    Route = route,
                    Category = category,
                    Directory = d,
                    RelativeDir = string.IsNullOrEmpty(relativePath) ? "snapshots" : "snapshots/" + relativePath,
                    Metadata = routeMetadata.GetValueOrDefault(route)
                };
            })
            .ToList();

        // Split into public and auth-required pages
        // Check for actual auth flow screenshots (1-initial.png exists), not just RequiresAuth flag
        // This catches pages that redirect to login even if not marked [Authorize] in code
        var authPages = allRoutes.Where(r => 
            File.Exists(Path.Combine(r.Directory, "1-initial.png")) ||
            r.Metadata?.RequiresAuth == true ||
            r.Metadata?.AuthFlowCompleted == true
        ).ToList();
        var publicPages = allRoutes.Where(r => !authPages.Contains(r)).ToList();
        
        var totalRoutes = allRoutes.Count;
        sb.AppendLine($"**{totalRoutes} page screenshots captured**");
        sb.AppendLine();

        // Quick status summary
        var successCount = routeMetadata.Values.Count(m => m.IsSuccess && !m.IsSuspiciouslySmall);
        var authCount = authPages.Count;
        var errorCount = routeMetadata.Values.Count(m => m.IsHttpError || m.IsError);
        
        sb.AppendLine("### Quick Status");
        sb.AppendLine();
        sb.AppendLine("| ✅ Success | 🔐 Auth Flow | ❌ Errors |");
        sb.AppendLine("|:----------:|:------------:|:---------:|");
        sb.AppendLine($"| {successCount} | {authCount} | {errorCount} |");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();

        // === PUBLIC PAGES SECTION ===
        sb.AppendLine($"### 🔓 Public Pages ({publicPages.Count})");
        sb.AppendLine();
        sb.AppendLine("Click on a screenshot to view full size.");
        sb.AppendLine();

        var publicByCategory = publicPages.GroupBy(r => r.Category).OrderBy(g => g.Key).ToList();

        foreach (var group in publicByCategory)
        {
            var categoryName = group.Key == "root" ? "Home" : group.Key;
            sb.AppendLine($"<details open>");
            sb.AppendLine($"<summary><strong>📁 {categoryName}</strong> ({group.Count()} pages)</summary>");
            sb.AppendLine();
            sb.AppendLine("<table>");
            
            var routes = group.OrderBy(r => r.Route).ToList();
            for (int i = 0; i < routes.Count; i += 3)
            {
                sb.AppendLine("<tr>");
                for (int j = 0; j < 3; j++)
                {
                    var idx = i + j;
                    if (idx < routes.Count)
                    {
                        var routeScreenshot = routes[idx];
                        var displayRoute = ShortenRoute(routeScreenshot.Route, 25);
                        var defaultPng = Path.Combine(routeScreenshot.Directory, "default.png");
                        string? imgPath = null;
                        
                        if (File.Exists(defaultPng))
                            imgPath = $"{routeScreenshot.RelativeDir}/default.png";
                        else
                        {
                            var anyPng = Directory.GetFiles(routeScreenshot.Directory, "*.png").FirstOrDefault();
                            if (anyPng != null)
                                imgPath = $"{routeScreenshot.RelativeDir}/{Path.GetFileName(anyPng)}";
                        }

                        sb.AppendLine("<td align=\"center\" width=\"33%\">");
                        if (imgPath != null)
                        {
                            sb.AppendLine($"<a href=\"{imgPath}\">");
                            sb.AppendLine($"<img src=\"{imgPath}\" width=\"250\" alt=\"{routeScreenshot.Route}\" />");
                            sb.AppendLine("</a>");
                        }
                        sb.AppendLine($"<br /><code>{displayRoute}</code>");
                        sb.AppendLine("</td>");
                    }
                    else
                        sb.AppendLine("<td></td>");
                }
                sb.AppendLine("</tr>");
            }
            
            sb.AppendLine("</table>");
            sb.AppendLine();
            sb.AppendLine("</details>");
            sb.AppendLine();
        }

        // === AUTH-REQUIRED PAGES (Grouped by Category like Public Pages) ===
        if (authPages.Count > 0)
        {
            sb.AppendLine("---");
            sb.AppendLine();
            sb.AppendLine($"### 🔐 Auth-Required Pages ({authPages.Count})");
            sb.AppendLine();
            sb.AppendLine("These pages redirected to login. Showing **final result** after authentication.");
            sb.AppendLine();
            sb.AppendLine("> 💡 Click step numbers to view: **①** redirect → **②** fill form → **③** result");
            sb.AppendLine();

            // Group by category (same as public pages)
            var authByCategory = authPages.GroupBy(r => r.Category).OrderBy(g => g.Key).ToList();

            foreach (var group in authByCategory)
            {
                var categoryName = group.Key == "root" ? "Home" : group.Key;
                sb.AppendLine($"<details open>");
                sb.AppendLine($"<summary><strong>📁 {categoryName}</strong> ({group.Count()} pages)</summary>");
                sb.AppendLine();
                sb.AppendLine("<table>");
                
                var routes = group.OrderBy(r => r.Route).ToList();
                for (int i = 0; i < routes.Count; i += 3)
                {
                    sb.AppendLine("<tr>");
                    for (int j = 0; j < 3; j++)
                    {
                        var idx = i + j;
                        if (idx < routes.Count)
                        {
                            var authRoute = routes[idx];
                            var displayRoute = ShortenRoute(authRoute.Route, 20);
                            var dir = authRoute.Directory;
                            var relDir = authRoute.RelativeDir;
                            
                            // Check which steps exist
                            var hasStep1 = File.Exists(Path.Combine(dir, "1-initial.png"));
                            var hasStep2 = File.Exists(Path.Combine(dir, "2-filled.png"));
                            var hasStep3 = File.Exists(Path.Combine(dir, "3-result.png"));
                            var hasDefault = File.Exists(Path.Combine(dir, "default.png"));
                            
                            // Show the final result (3-result.png) as the main image
                            string? imgPath = null;
                            if (hasStep3)
                                imgPath = $"{relDir}/3-result.png";
                            else if (hasDefault)
                                imgPath = $"{relDir}/default.png";

                            sb.AppendLine("<td align=\"center\" width=\"33%\">");
                            if (imgPath != null)
                            {
                                sb.AppendLine($"<a href=\"{imgPath}\">");
                                sb.AppendLine($"<img src=\"{imgPath}\" width=\"250\" alt=\"{authRoute.Route}\" />");
                                sb.AppendLine("</a>");
                            }
                            
                            // Build step links: route 🔐 [①][②][③]
                            var stepLinks = new StringBuilder();
                            if (hasStep1)
                                stepLinks.Append($"<a href=\"{relDir}/1-initial.png\" title=\"Step 1: Redirect\">①</a>");
                            if (hasStep2)
                                stepLinks.Append($"<a href=\"{relDir}/2-filled.png\" title=\"Step 2: Fill Form\">②</a>");
                            if (hasStep3)
                                stepLinks.Append($"<a href=\"{relDir}/3-result.png\" title=\"Step 3: Result\">③</a>");
                            
                            sb.AppendLine($"<br /><code>{displayRoute}</code> 🔐 {stepLinks}");
                            sb.AppendLine("</td>");
                        }
                        else
                            sb.AppendLine("<td></td>");
                    }
                    sb.AppendLine("</tr>");
                }
                
                sb.AppendLine("</table>");
                sb.AppendLine();
                sb.AppendLine("</details>");
                sb.AppendLine();
            }

            // Add a single expandable section showing the auth flow pattern
            sb.AppendLine("<details>");
            sb.AppendLine("<summary>🔍 <strong>View Auth Flow Pattern</strong> (same for all protected pages)</summary>");
            sb.AppendLine();
            sb.AppendLine("All protected pages follow this login flow:");
            sb.AppendLine();
            sb.AppendLine("| Step | Action | Screenshot |");
            sb.AppendLine("|:----:|--------|:----------:|");
            
            // Use first auth route as example
            var exampleRoute = authPages.First();
            var exDir = exampleRoute.RelativeDir;
            var hasEx1 = File.Exists(Path.Combine(exampleRoute.Directory, "1-initial.png"));
            var hasEx2 = File.Exists(Path.Combine(exampleRoute.Directory, "2-filled.png"));
            var hasEx3 = File.Exists(Path.Combine(exampleRoute.Directory, "3-result.png"));
            
            if (hasEx1)
                sb.AppendLine($"| ① | **Redirect** — User hits protected route, sent to `/Account/Login` | <img src=\"{exDir}/1-initial.png\" width=\"150\"/> |");
            if (hasEx2)
                sb.AppendLine($"| ② | **Fill Form** — Enter credentials: `admin@test.com` | <img src=\"{exDir}/2-filled.png\" width=\"150\"/> |");
            if (hasEx3)
                sb.AppendLine($"| ③ | **Result** — Login successful, user sees protected content | <img src=\"{exDir}/3-result.png\" width=\"150\"/> |");
            
            sb.AppendLine();
            sb.AppendLine("</details>");
            sb.AppendLine();
        }

        await Task.CompletedTask;
    }

    private static FileEntry? ParseCsvLine(string line)
    {
        if (string.IsNullOrWhiteSpace(line)) return null;

        var fields = new List<string>();
        var inQuotes = false;
        var currentField = new StringBuilder();

        foreach (var c in line)
        {
            if (c == '"')
            {
                inQuotes = !inQuotes;
            }
            else if (c == ',' && !inQuotes)
            {
                fields.Add(currentField.ToString());
                currentField.Clear();
            }
            else
            {
                currentField.Append(c);
            }
        }
        fields.Add(currentField.ToString());

        if (fields.Count < 10) return null;

        return new FileEntry
        {
            FilePath = fields[0],
            RelativePath = fields[1],
            Extension = fields[2],
            SizeBytes = long.TryParse(fields[3], out var size) ? size : 0,
            LineCount = long.TryParse(fields[4], out var lines) ? lines : 0,
            CharCount = long.TryParse(fields[5], out var chars) ? chars : 0,
            Kind = fields.Count > 9 ? fields[9] : ""
        };
    }

    private static string GenerateProgressBar(double percentage, int width)
    {
        var filled = (int)(percentage * width / 100.0);
        filled = Math.Clamp(filled, 0, width);
        var empty = width - filled;
        return $"[{'█'.ToString().PadRight(filled, '█')}{'░'.ToString().PadRight(empty, '░')}]";
    }

    private static string ShortenPath(string path, int maxLength)
    {
        if (path.Length <= maxLength) return path;
        return "..." + path[^(maxLength - 3)..];
    }

    private static string ShortenRoute(string route, int maxLength)
    {
        if (route.Length <= maxLength) return route;
        
        var segments = route.Split('/', StringSplitOptions.RemoveEmptyEntries);
        if (segments.Length <= 2)
        {
            return "..." + route[^(maxLength - 3)..];
        }
        
        var first = segments[0];
        var last = segments[^1];
        var shortened = $"/{first}/.../{last}";
        
        if (shortened.Length <= maxLength)
        {
            return shortened;
        }
        
        return $".../{last}";
    }

    private static string FindRepoRoot(string startPath)
    {
        var dir = new DirectoryInfo(startPath);
        while (dir is not null)
        {
            if (Directory.Exists(Path.Combine(dir.FullName, ".git")) ||
                dir.GetFiles("*.sln").Length > 0)
            {
                return dir.FullName;
            }
            dir = dir.Parent;
        }
        return Path.GetFullPath(Path.Combine(startPath, "..", "..", "..", "..", ".."));
    }

    private class FileEntry
    {
        public string FilePath { get; set; } = "";
        public string RelativePath { get; set; } = "";
        public string Extension { get; set; } = "";
        public long SizeBytes { get; set; }
        public long LineCount { get; set; }
        public long CharCount { get; set; }
        public string Kind { get; set; } = "";
    }

    private class RouteEntry
    {
        public string Route { get; set; } = "";
        public bool RequiresAuth { get; set; }
        public string Project { get; set; } = "";
    }

    private class WorkspaceStats
    {
        public int TotalFiles { get; set; }
        public long TotalLines { get; set; }
        public long TotalSize { get; set; }
    }

    // Helper class for route screenshots
    private class RouteScreenshots
    {
        public string Route { get; set; } = "";
        public string Category { get; set; } = "";
        public string Directory { get; set; } = "";
        public string RelativeDir { get; set; } = "";
        public ScreenshotHealthEntry? Metadata { get; set; }
    }

    private class ScreenshotHealthEntry
    {
        public string Route { get; set; } = "";
        public string Url { get; set; } = "";
        public int StatusCode { get; set; }
        public long FileSize { get; set; }
        public bool IsSuspiciouslySmall { get; set; }
        public bool RetryAttempted { get; set; }
        public List<string>? ConsoleErrors { get; set; }
        public DateTime CapturedAt { get; set; }
        public bool IsSuccess { get; set; }
        public bool IsHttpError { get; set; }
        public bool IsError { get; set; }
        public string? ErrorMessage { get; set; }
        
        // Auth flow fields
        public bool RequiresAuth { get; set; }
        public bool AuthFlowCompleted { get; set; }
        public string? AuthStep1Path { get; set; }
        public string? AuthStep2Path { get; set; }
        public string? AuthStep3Path { get; set; }
        public string? AuthFlowNote { get; set; }
    }
}
